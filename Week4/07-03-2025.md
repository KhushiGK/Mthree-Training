# Python OOP Concepts and File Handling

This document covers various Python Object-Oriented Programming (OOP) concepts such as inheritance, polymorphism, method overriding, abstraction, encapsulation, constructor, destructor, getter and setter, shallow copy, deep copy, class method, static method, and class variables. Additionally, it includes exception handling and file handling operations.

## Inheritance, Polymorphism, Method Overriding, and Encapsulation

### Explanation:
- **Inheritance:** It allows a class (child) to acquire properties and behaviors of another class (parent), promoting code reusability.
- **Method Overriding:** A subclass can redefine a method of its parent class to provide a specific implementation.
- **Polymorphism:** A single interface can represent different underlying forms (e.g., multiple classes having a `speak()` method but implementing it differently).
- **Encapsulation:** It restricts direct access to some of an object's components, ensuring controlled modification through methods like getters and setters.

### Implementation:
```python
class Animal:
    def __init__(self, name):  # Constructor initializes the object
        self.name = name  # Encapsulated variable
    
    def __str__(self):  # String representation
        return f"Animal {self.name}"
    
    def speak(self):
        return f"Animal {self.name} is speaking"

# Method Overriding and Overloading
class Dog(Animal):
    def speak(self, age=0):  # Overloaded method with an optional parameter
        return f"Dog {self.name} is barking and {age} years old"
    
    def __str__(self):
        return f"Dog {self.name}"

class Cat(Animal):
    def speak(self):
        return f"Cat {self.name} is meowing"

class Bird(Animal):
    def speak(self):
        return f"Bird {self.name} is chirping"

def main():
    dog1 = Animal("Biddy2")
    print(dog1.speak())  # Calls parent class method
    
    dog = Dog("Buddy")
    print(dog.speak())  # Calls overridden method with default age
    print(dog.speak(10))  # Calls overridden method with provided age
    print(dog)  # Calls overridden __str__ method
    
    dog1 = Dog("Buddy1")
    print(dog1.speak(10))

if __name__ == "__main__":
    main()
```

### Expected Output:
```
Animal Biddy2 is speaking
Dog Buddy is barking and 0 years old
Dog Buddy is barking and 10 years old
Dog Buddy
Dog Buddy1 is barking and 10 years old
```

---

## Shallow Copy and Deep Copy

### Explanation:
- **Shallow Copy:** Creates a new object but does not create copies of nested objects. Instead, it copies references to the nested objects.
- **Deep Copy:** Creates a new object and recursively copies all objects within it, making them completely independent.

### Implementation:
```python
import copy

class Person:
    def __init__(self, name, address):
        self.name = name
        self.address = address
    
    def __repr__(self):
        return f"Person(name={self.name}, address={self.address})"

class Address:
    def __init__(self, city, country):
        self.city = city
        self.country = country
    
    def __repr__(self):
        return f"Address(city={self.city}, country={self.country})"

# Create a person with an address
address = Address("New York", "USA")
person = Person("John", address)

# Create a shallow copy
shallow_person = copy.copy(person)

# Create a deep copy
deep_person = copy.deepcopy(person)

# Verify the objects are different
print(f"Original person ID: {id(person)}")
print(f"Shallow copy person ID: {id(shallow_person)}")
print(f"Deep copy person ID: {id(deep_person)}")

# Check the address object IDs
print(f"Original address ID: {id(person.address)}")
print(f"Shallow copy address ID: {id(shallow_person.address)}")
print(f"Deep copy address ID: {id(deep_person.address)}")

# Modify original address
person.address.city = "Boston"

# Print updated objects
print(f"Original person: {person}")
print(f"Shallow copy person: {shallow_person}")  # City will be Boston
print(f"Deep copy person: {deep_person}")        # City remains New York
```

---

## Exception Handling

### Explanation:
- **Try-Except Block:** Handles errors and prevents program crashes.
- **Custom Exceptions:** Allows creating user-defined exceptions for specific error handling.
- **Finally Block:** Ensures that cleanup actions execute regardless of an exception occurring.

### Implementation:
```python
class CustomException(Exception):
    def __init__(self, message):
        self.message = message
        super().__init__(self.message)

try:
    raise CustomException("This is a custom exception")
except CustomException as e:
    print(e)
except Exception as e:
    print(e)
finally:
    print("Finally block executed")
```

### Expected Output:
```
This is a custom exception
Finally block executed
```

---

## File Handling

### Explanation:
- **Basic File Operations:** Create, write, read, and append text files.
- **File Deletion and Existence Check:** Ensures file management.
- **Fetching File Information:** Retrieves file metadata such as size and last modification time.

### Implementation:
```python
import os

FILE_PATH = "test.txt"

def create_file():
    with open(FILE_PATH, "w") as file:
        file.write("Hello, World!\n")

def write_to_file():
    with open(FILE_PATH, "w") as file:
        file.write("This is a new line\n")

def read_from_file():
    with open(FILE_PATH, "r") as file:
        print(file.read())

def append_to_file():
    with open(FILE_PATH, "a") as file:
        file.write("Appending text\n")

def delete_file():
    if os.path.exists(FILE_PATH):
        os.remove(FILE_PATH)
    else:
        print("File does not exist")

def check_if_file_exists():
    print("File exists" if os.path.exists(FILE_PATH) else "File does not exist")

if __name__ == "__main__":
    create_file()
    write_to_file()
    read_from_file()
    append_to_file()
    delete_file()
    create_file()
    write_to_file()
    check_if_file_exists()
```
